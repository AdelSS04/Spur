using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace Spur.Generators;

/// <summary>
/// Source generator for creating AOT-friendly ToHttpResult extension methods.
/// Generates specialized methods for each Result type used in the application.
/// </summary>
[Generator]
public sealed class ToHttpResultGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register a marker attribute for users to opt-in to generation
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "GenerateToHttpResultAttribute.g.cs",
            SourceText.From(GenerateAttributeSource(), Encoding.UTF8)));

        // Find all classes/records marked with [GenerateToHttpResult]
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsTargetForGeneration(node),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null)
            .Collect();

        // Generate the source
        context.RegisterSourceOutput(provider, static (spc, source) => Execute(source!, spc));
    }

    private static bool IsTargetForGeneration(SyntaxNode node)
    {
        // Look for classes or records with attributes
        return node is ClassDeclarationSyntax or RecordDeclarationSyntax;
    }

    private static TypeDeclarationInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;

        // Check if it has the GenerateToHttpResult attribute
        var hasAttribute = typeDeclaration.AttributeLists
            .SelectMany(al => al.Attributes)
            .Any(attr => attr.Name.ToString().Contains("GenerateToHttpResult"));

        if (!hasAttribute)
        {
            return null;
        }

        var semanticModel = context.SemanticModel;
        var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration);

        if (typeSymbol == null)
        {
            return null;
        }

        var namespaceName = SyntaxHelpers.GetNamespace(typeDeclaration);

        return new TypeDeclarationInfo(
            typeSymbol.Name,
            namespaceName ?? string.Empty,
            typeDeclaration.Keyword.ValueText); // "class" or "record"
    }

    private static void Execute(ImmutableArray<TypeDeclarationInfo> types, SourceProductionContext context)
    {
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        foreach (var type in types)
        {
            var source = GenerateExtensionClass(type);
            context.AddSource($"{type.Name}Extensions.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateAttributeSource()
    {
        return """
            using System;

            namespace Spur.Generators
            {
                /// <summary>
                /// Marks a type to generate AOT-friendly ToHttpResult extension methods.
                /// </summary>
                [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false)]
                internal sealed class GenerateToHttpResultAttribute : Attribute
                {
                }
            }
            """;
    }

    private static string GenerateExtensionClass(TypeDeclarationInfo type)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(type.Namespace))
        {
            sb.AppendLine($"namespace {type.Namespace};");
            sb.AppendLine();
        }

        sb.AppendLine("using Microsoft.AspNetCore.Http;");
        sb.AppendLine("using Spur;");
        sb.AppendLine("using Spur.AspNetCore;");
        sb.AppendLine();

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Generated AOT-friendly ToHttpResult extensions for {type.Name}.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"internal static partial class {type.Name}HttpResultExtensions");
        sb.AppendLine("{");

        // Generate ToHttpResult method
        sb.AppendLine($"    public static IResult ToHttpResult(this Result<{type.Name}> result, IProblemDetailsMapper mapper)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (result.IsSuccess)");
        sb.AppendLine("        {");
        sb.AppendLine("            return Results.Ok(result.Value);");
        sb.AppendLine("        }");
        sb.AppendLine("        return Results.Problem(mapper.ToProblemDetails(result.Error));");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate async version
        sb.AppendLine($"    public static async System.Threading.Tasks.Task<IResult> ToHttpResultAsync(");
        sb.AppendLine($"        this System.Threading.Tasks.Task<Result<{type.Name}>> resultTask,");
        sb.AppendLine("        IProblemDetailsMapper mapper)");
        sb.AppendLine("    {");
        sb.AppendLine("        var result = await resultTask.ConfigureAwait(false);");
        sb.AppendLine("        return result.ToHttpResult(mapper);");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }

    private sealed class TypeDeclarationInfo
    {
        public string Name { get; }
        public string Namespace { get; }
        public string Kind { get; }

        public TypeDeclarationInfo(string name, string @namespace, string kind)
        {
            Name = name;
            Namespace = @namespace;
            Kind = kind;
        }
    }
}
